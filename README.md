# Getting Started
Engineering Values encapsulate the engineering organization’s culture - what we value and how we work together as humans.

## Our Values

### The Best Solution

My success depends on our success. The best solution is the one that is best for the team.

### Skepticism of our Work

I know that mistakes are normal and common. I assume my work is broken until I prove otherwise.

### Experimentation

I must have a constant sense of curiosity and adaptability for improving myself, my work, our products, and my team. This requires me to fail fast and fail often to learn new things.

### The Pit of Success

Because others will share in my work, I must ensure that the work I produce guides my team toward good practices by making bad practices difficult.

### Ownership

I must take pride in my work and nurture it to ensure the success of my team and our company. Outstanding craftsmanship is vital to me.


## Engineering Ethical Expectations

How do we instill within us the knowledge and desire to profess a set of ethics? 

One way might be to have expectations. So, here are our expectations of our engineering team.

Source: [Professionalism by Uncle Bob](https://www.youtube.com/embed/Qjywrq2gM8o?start=576&autoplay=1)

### We will not ship shit - [video](https://www.youtube.com/embed/Qjywrq2gM8o?start=1080&end=1300&autoplay=1) (4m)

- Our code should be clean, tested, and well organized.

### We'll always be ready - [video](https://www.youtube.com/embed/Qjywrq2gM8o?start=1300&end=1557&autoplay=1) (5m)

- From a technical point of view, the system is ready to deploy.
- All testing & documentation are done at the end of every sprint.

### Stable productivity - [video](https://www.youtube.com/embed/Qjywrq2gM8o?start=1557&end=1697&autoplay=1)  (3m)

- The longer the project goes, the slower we DON'T get.
- We are able to produce features at the same rate at the beginning, middle, and end of the project.
- We are steadily productive.

### Inexpensive Adaptability - [video](https://www.youtube.com/embed/Qjywrq2gM8o?start=1697&end=1837&autoplay=1) (3m)

- It should be cheap and easy to make changes.
- The cost of the change should be proportional to the scope.
- Software, by definition, is made to be easily changed.

### Continuous Improvement - [video](https://www.youtube.com/embed/Qjywrq2gM8o?start=1837&end=1908&autoplay=1) (2m)

- The code should be getting better with time.
- The design and architecture should improve over time.

### Fearless Competence - [video](https://www.youtube.com/embed/Qjywrq2gM8o?start=1908&end=2552&autoplay=1) (11m)

  - We keep control over our code.
  - It's wildly irresponsible to fear what we create.
  - We should not be fearful of refactors, cleaning code, or architecture improvements.
  - We do not write fragile tests, they are an integral part of the system.
  - 100% coverage - [asymptotic goal](https://en.wikipedia.org/wiki/Asymptotic_theory_(statistics)#:~:text=A%20primary%20goal%20of%20asymptotic,be%20obtained%20by%20numerical%20methods.)  to reasonably expect no percentage of the system can not work.

### We will not dump on QA - [video](https://www.youtube.com/embed/Qjywrq2gM8o?start=2558&end=2790&autoplay=1) (4m)

  - QA is not the tool we use to find bugs in our system.
  - It's the developers job to make sure the system works.
  - QA should specify how the system should work.

### Automation - [video](https://www.youtube.com/embed/Qjywrq2gM8o?start=2791&end=3084&autoplay=1) (5m) 

  - Every test should be automated.
  - If a computer can do it then a computer should do it.
  - No percentage of the system should be reasonably untested.
  - Defects are not incentivized.
  - We can meet any schedule given the code doesn't have to work.

### We cover for each other - [video](https://www.youtube.com/embed/Qjywrq2gM8o?start=3087&end=3342&autoplay=1) (5m)

  - We're a team and we behave as one.
  - When one of our team members slip, we cover for them.
  - It's my responsibility to ensure someone can cover for me.
  - Pair programming.

### Honest Estimates - [video](https://www.youtube.com/embed/Qjywrq2gM8o?start=3342&end=3581&autoplay=1)  (4m)

  - I don't know is a reasonable answer.
  - We'll provide 3 estimates:
    - Optimistic - best case as if stars aligned
    - Pessimistic - worst case scenario
    - Likely - a realistic happy path.
  - We define a boundary of what we don't know.

### Clean Code

1.  Meaningful Names: Use descriptive names for variables, functions, classes, and modules. Avoid abbreviations and single-letter names.
  
2.  Functions should be small and do one thing: Functions should be no longer than a few lines of code and should only perform one task.
  
3.  Keep code organized: Organize code into modules, classes, and functions that are cohesive and have a clear purpose.
  
4.  Comments should be avoided: Instead of relying on comments, write code that is self-explanatory and easy to understand.
  
5.  Don't Repeat Yourself (DRY): Avoid duplication in code by using abstraction, inheritance, and composition.
  
6.  Keep functions pure: Functions should not have side effects and should only modify their input parameters.
  
7.  Error handling should be done centrally: Errors should be handled in a central location in the code, rather than being scattered throughout.
  
8.  Tests are essential: Write tests for every piece of code, and make sure they run quickly and reliably.
  
9.  Keep the code simple: Simplicity is key. Avoid complexity unless it's absolutely necessary.
  
10.  Use consistent formatting: Use consistent formatting throughout the codebase to make it easier to read and maintain.


## Our guiding principles

> _Because others will share in my work, I must ensure that the work I produce guides my team toward good practices by making bad practices difficult_

 >Pragmatically, development is a never stopping process of reviewing previous decisions and making improvements.
 
 
### The Broken Window Theory - [blog](https://blog.codinghorror.com/the-broken-window-theory/)

> Don't leave "broken windows" (bad designs, wrong decisions, or poor code) un-repaired. Fix each one as soon as it is discovered. If there is insufficient time to fix it properly, then board it up. Perhaps you can comment out the offending code, or display a "Not Implemented" message, or substitute dummy data instead. Take some action to prevent further damage and to show that you're on top of the situation.

### Go Faster, Slow Down - [blog](https://www.infoq.com/articles/slow-down-go-faster/)

- Rushing makes us neither faster, nor more productive; it increases stress and distracts focus. We need creativity, effectiveness, and focus.
- Hire better talents, do together, practice together and learn together to improve professionalism and cultivate craftsmanship in your organization. 
- Improve adaptation of your team and efficiency of your processes by doing plans & revising them often, collecting & analyzing and eliminating waste.
- Without having a quality codebase, you cannot be agile. Push defects down, release frequently, test first and refactor and focus on simple design.
- Working software doesn’t have to be well-crafted. Only good professionals can build well-crafted software, and only well-crafted software lets you build faster than ever.

### Every Engineer is an Architect - [blog](https://dzone.com/articles/the-architect-title-over-specialization)

> Any developer should be an architect in the sense that any developer should be concerned with both the big picture of the software and the details thereof.

### The Boy Scout Rule - [blog](https://biratkirat.medium.com/step-8-the-boy-scout-rule-robert-c-martin-uncle-bob-9ac839778385)

> Leave things BETTER than you found them. ~ Robert Baden Powell

> Always leave the code you're editing a little better than you found it. ~ Uncle Bob

### YAGNI - [blog](https://deviq.com/principles/yagni)

> You Ain't Gonna Need It

> Always implement things when you _**actually**_ need them, never when you just _**foresee**_ that you _**may**_ need them.

### Iron Triangle - [blog](https://www.visual-paradigm.com/project-management/what-is-iron-triangle-of-projects/)


### Aha! Programming - [blog](https://kentcdodds.com/blog/aha-programming)

#### DRY

- Don't repeat yourself
- Every piece of knowledge must have a single, unambiguous, authoritative representation within a system.

#### WET

- Write Everything Twice.
- You can ask yourself "Haven't I written this before?" two times, but never three.

#### AHA - [blog](https://kentcdodds.com/blog/aha-programming)

- Avoid Hasty Abstractions
- Prefer duplication over the wrong abstraction
- Optimize for change first

### Naming Clarity and Brevity - [blog](https://signalvnoise.com/posts/3250-clarity-over-brevity-in-variable-and-method-names)

- If you work hard at being clear in your naming, you’ll also rarely need to write comments for the code.
- Comments are generally only needed when you failed to be clear enough in naming. Treat them as a code smell.

### Conventional commits - [source](https://www.conventionalcommits.org/en/v1.0.0-beta.2/#summary)

### Write Tests - Not Too Many  - [blog](https://kentcdodds.com/blog/write-tests)

- Write tests. Not too many. Mostly integration.
- Testing Trophy
  - End-to-End
  - Integration
  - Unit
  - Static

### SOLID - [blog](https://www.bmc.com/blogs/solid-design-principles/#:~:text=SOLID%20is%20an%20acronym%20that,some%20important%20benefits%20for%20developers.)

#### Single Responsibility

- A class should have one, and only one, reason to change.
- Each class only does one thing.
- Every module has one responsibility.

#### Open-Closed

- Open for extension 
  - Meaning the class's behavior can be extended upon.
- Closed for modification
  - Mean that the source code is set and cannot be changed.

#### Liskov Substitution

- Every derived class should be substitutable for its parent.
  - This means an imported class should be mockable.

#### Interface Segregation

- It's better to have a lot of smaller interfaces than a few bigger ones.
- Make fine grained interfaces that are client-specific
- Clients should not be forced to implement interfaces they do not use.

#### Dependency Inversion

- Depend on abstractions, not concretions.
- `new` is glue.
- High level modules should not depend upon lower level modules. 
- Both should depend on abstractions.
- Abstractions should not depend on details.
- Details should not depend upon abstractions.

